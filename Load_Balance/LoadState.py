from consts import SHIP_VIRTUAL_CELL
from Load_Balance.State import State
from Load_Balance.Position import Position, Location
from Move import Move
from ContainerData import ContainerData
import copy

'''
    State subclass for Loading/unloading
    goal state is when there are no containers to load or unload
    next_states generates all possible states that can be reached from the current state
        states are generated by 
            unloading containers, and moving containers in the way
            loading containers from the truck into the ship
            moving the crane back to the crane rest
            moving containers out of the buffers
    the heuristic of a state is 
        manhattan distance of each container to unload
        distance to load any container
        distance to move each container out of the buffers
'''
class LoadState(State):
    def __init__(self, containers_to_load=[], containers_to_unload=[], manifest=None):
        self.containers_to_load = containers_to_load
        self.containers_to_unload = containers_to_unload
        super().__init__(manifest)
    
    # calculate the heuristic cost of this state
    def calculate_h(self):
        self.h = 0

        # manhattan distance of each container to unload to ship virtual cell + 2*number of containers above it
        for pos in self.containers_to_unload:
            self.h += abs(pos.m - SHIP_VIRTUAL_CELL[0]) + abs(pos.n - SHIP_VIRTUAL_CELL[1])
            for above in self.containers_above(pos):
                self.h += self.search_from(above, True, True)[1]


        # distance to load any container to the best open position in the ship
        self.h += max(len(self.containers_to_load), 1)*self.search_from(Position(Location.SHIP, SHIP_VIRTUAL_CELL), False, False)[1]*2

        # best cost to move each container out of the buffers
        for pos in self.containers_in_buffers():
            self.h += self.search_from(pos, False, False)[1]*2

        # distance to move the crane to the crane rest
        if not self.crane_position.in_crane_rest():
            self.h += self.crane_position.move_to(Position(Location.CRANE_REST), apply_move=False)[1]

    def next_states(self):
        states = []

        self.load(states)              # generate state produced by loading a container
        self.unload(states)            # generate states produced by unloading a container
        self.clear_buffers(states)     # generate states produced by moving containers out of the buffers
        self.return_crane_rest(states) # generate state produced by moving the crane back to the crane rest

        return states
    
    # check if the state is a goal state
    # if there are no containers to load or unload
    # if there are no containers in the buffers
    # if the crane is at rest position
    def is_goal(self):
        return not self.containers_to_load and not self.containers_to_unload and not self.containers_in_buffers() and self.crane_position.in_crane_rest()

    # generate states by loading any container from the truck into the ship
    def load(self, states):
        if self.containers_to_load:
            state = copy.deepcopy(self)
            container = state.containers_to_load.pop()

            # move to the truck
            if not self.crane_position.in_truck():
                (prev, cost) = state.crane_position.move_to(Position(Location.TRUCK))
                state.moves.append(Move(prev, copy.deepcopy(state.crane_position), cost))
                state.g += cost

            # move to virtual cell
            (_, costV) = state.crane_position.move_to(Position(Location.SHIP, SHIP_VIRTUAL_CELL))
            state.g += costV

            # get the best open position in the ship
            (open, cost) = state.search_from(Position(Location.SHIP, SHIP_VIRTUAL_CELL), False, False, state.unloading_containers_below)
            if open is None:
                return

            # move the container to the open position from truck
            (_, cost) = state.crane_position.move_to(open, cost)
            state.moves.append(Move(Position(Location.TRUCK), copy.deepcopy(state.crane_position), cost+costV, container))
            state.g += cost

            # set the container at the open position
            state.ship[open.m][open.n] = container
            state.ship_height_map[open.n] -= 1

            state.calculate_h()

            states.append(state)


    # generate states by unloading all containers to unload
    def unload(self, states):
        for i in range(len(self.containers_to_unload)):
            pos = self.containers_to_unload[i]

            state = copy.deepcopy(self)
            state.containers_to_unload.pop(i)
            container = state.ship[pos.m][pos.n]

            containers_above = state.containers_above(pos)
            prev = self.crane_position
            bad = False
            while containers_above:
                above_pos = containers_above.pop()
                if above_pos in state.containers_to_unload:
                    bad = True
                    break
                # move to the current container to move
                if prev != above_pos:
                    (prev, cost) = state.crane_position.move_to(above_pos, state.ship if above_pos.in_ship() else state.buffer)
                    state.moves.append(Move(prev, above_pos, cost))
                    state.g += cost

                # search for a good place to move the container
                (move_to, cost) = state.search_from(above_pos, True, True, state.unloading_containers_below)
                state.swap(above_pos, move_to)
                state.crane_position = copy.deepcopy(move_to)
                state.moves.append(Move(above_pos, move_to, cost, state.ship[move_to.m][move_to.n]))
                state.g += cost

            if bad:
                continue

            # move to the container
            if state.crane_position != pos:
                (prev, cost) = state.crane_position.move_to(pos, state.ship if pos.in_ship() else state.buffer)
                state.moves.append(Move(prev, pos, cost))
                state.g += cost

            # move the container to the truck
            (prev, cost) = state.crane_position.move_to(Position(Location.TRUCK))
            state.moves.append(Move(prev, Position(Location.TRUCK), cost, container))
            state.g += cost

            # remove the container from the ship
            state.ship[prev.m][prev.n] = ContainerData()
            state.ship_height_map[prev.n] += 1

            state.calculate_h()

            states.append(state)
    
    # count the number of containers that need to be unloaded below the given position
    # times an estimated cost to move a container elsewhere
    def unloading_containers_below(self, pos):
        count = 0
        curr_pos = copy.deepcopy(pos)
        while curr_pos.move_down():
            if curr_pos in self.containers_to_unload:
                count += 4
        return count
        